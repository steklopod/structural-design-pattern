# Структурные паттерны

- [Адаптер](#adapter)
- [Компоновщик](#composite)
- [Декоратор](#decorator)
- [Фасад](#facade)

#### _Cтруктурные паттерны (structural patterns)_ описывают создание более сложных объектов, либо упрощают работу с другими объектами системы.

`Adapter` - на основании некоторого класса создаем необходимый клиенту интерфейс;

`Composite` - работаем с базовыми и составными объектами единым образом;

`Decorator` - динамически добавляем новую функциональность некоторому объекту, сохраняя его интерфейс;

`Facade` - описываем унифицированный интерфейс для облегчения работы с набором подсистем;

`*Proxy` - создаем объект, который перехватывает вызовы к другому объекту;

`*Bridge` - разделяем абстракцию от интерфейса, позволяя им меняться независимо;

`*Flyweight` - эффективно работаем с огромным количеством схожих объектов.

-------------

> Адаптер (Adapter) <a name="adapter"></a>

Часто в новом программном проекте не удается повторно использовать уже существующий код. Например, имеющиеся классы могут обладать нужной функциональностью, но иметь при этом несовместимые интерфейсы. В таких случаях следует использовать паттерн Adapter (адаптер).

Паттерн Adapter, представляющий собой программную обертку над существующими классами, преобразует их интерфейсы к виду, пригодному для последующего использования.

- На основании некоторого класса создаем необходимый клиенту интерфейс;

- Мост между двумя интерфейсами (полезно, когда мы работаем с легаси-кодом).

###### _Недостатки_:

- Задача преобразования интерфейсов может оказаться непростой в случае, если клиентские вызовы и (или) передаваемые параметры не имеют функционального соответствия в адаптируемом объекте.

-------------

> Компоновщик (Composite) <a name="composite"></a>

`Composite(композиция) ` — **паттерн, структурирующий объекты**, составной объект, который может включать в себя другие объекты.

Предоставляет клиенту единообразный доступ к листовым и составным элементам древовидной структуры.

[Русская WikiPedia](https://ru.wikipedia.org/wiki/Компоновщик_(шаблон_проектирования))

**Используйте если**:

- Необходимо объединять группы схожих объектов и управлять ими;

- Объекты могут быть как примитивными (элементарными), так и составными (сложными). Составной объект может включать в себя коллекции других объектов, образуя сложные древовидные структуры. Пример: директория файловой системы состоит из элементов, каждый их которых также может быть директорией;

- Код клиента работает с примитивными и составными объектами единообразно.


###### _Недостатки_:

- Very costly to create more composite impl;

- Неудобно осуществить запрет на добавление в составной объект Composite объектов определенных типов. Так, например, в состав римской армии не могут входить боевые слоны.

-------------

## Декоратор (Decorator) <a name="decorator"></a>

- Wrapper

- Add functionality or behavior

- Single Responsibility Principle

- Dynamically compose behavior

- Inheritance and Composition

## _Недостатки_:

- New Class for every feature

- no of objects (more)

- more comples for the clients

-------------

## Фасад (Facade) <a name="facade"></a>

- Make API easy 

- Interface not required

- usually a refactoring pattern

## _Недостатки_:

- Over usage

- Clean up design pattern

----------

> *См также на моем GitHub [github.com/steklopod](http://www.github.com/steklopod):

## Паттерны создания объектов:

**Creational паттерны**  в той или иной степени работают с механизмами создания объектов.

`Singleton` - обеспечиваем существование в системе ровно одного экземпляра некоторого класса;

`Factory` Method - делегируем процесс создания объектов классам-наследникам;

`Prototype` - клонируем объекты на основании некоторого базового объекта;

`Builder` - отделяем процесс создания комплексного объекта от его представления;

`Abstract Factory` - описываем сущность для создания целых семейств взаимосвязанных объектов.

`Структурные паттерны`

---------

## Поведенческие паттерны проектирования

Поведенческие шаблоны (behavioral) -  определяют эффективные способы взаимодействия различных объектов в системе.

`Strategy` - описываем набор взаимозаменяемых алгоритмов с единым интерфейсом;

`Iterator` - обеспечиваем доступ к коллекциям объектов без раскрытия внутреннего устройства этих коллекций;

`Observer` - создаем объект для отслеживания изменений в подсистеме и нотификации других подсистем;

`Memento` - сохраняем внутреннее состояние объекта для последующего использования без нарушения инкапсуляции;

`Command` - описываем объект, представляющий собой некоторое действие, которое можно выполнить в необходимый момент;

`Interpreter` - определяем способ вычисления выражений некоторого языка;

`Mediator` - создаем объект, которые регулирует взаимодействие между набором подсистем;

`State` - позволяем объекту менять свое поведение при изменении его внутреннего состояния;

`Template method` - описываем алгоритм, возлагая реализацию некоторых частей алгоритма на подклассы;

`Visitor` - отделяем алгоритм от структуры, с которыми алгоритм работает;

`Chain of responsibility` - пропускаем некоторый запрос через набор обработчиков событий, до тех пор пока запрос не будет обработан.

Репозиторий проекта: [www.github.com/steklopod/structural-design-pattern](http://www.github.com/steklopod/structural-design-pattern)

 `d.a.kaltovich@gmail.com`