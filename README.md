# Структурные паттерны ???
- [Адаптер](#adapter)
- [Композиция](#composite)
- [Декоратор](#decorator)
- [Фасад](#facade)

## Адаптер (Adapter) <a name="adapter"></a>
- На основании некоторого класса создаем необходимый клиенту интерфейс.
- Bridge between 2 interfaces (Useful when we work with Legacy code)

### Недостатки:
- No new functionalities
- Multiple Adapters

## Композиция (Composite) <a name="composite"></a>
- Tree structure
- Component
- Leaf
- Composite

### Недостатки:
- Very costly to create more composite impl
- Overly simple

## Декоратор (Decorator) <a name="decorator"></a>
- Wrapper
- Add functionality or behavior
- Single Responsibility Principle
- Dynamically compose behavior
- Inheritance and Composition

## Недостатки:
- New Class for every feature
- no of objects (more)
- more comples for the clients

## Фасад (Facade) <a name="facade"></a>
- Make API easy 
- Interface not required
- usually a refactoring pattern

## Недостатки:
- Over usage
- Clean up design pattern


-----------------------
##Паттерны создания объектов:
Первая группа - это creational паттерны. Они в той или иной степени работают с механизмами создания объектов.

`Singleton` - обеспечиваем существование в системе ровно одного экземпляра некоторого класса;
`Factory` Method - делегируем процесс создания объектов классам-наследникам;
`Prototype` - клонируем объекты на основании некоторого базового объекта;
`Builder` - отделяем процесс создания комплексного объекта от его представления;
`Abstract Factory` - описываем сущность для создания целых семейств взаимосвязанных объектов.
Структурные паттерны

##Вторая группа - структурные паттерны (structural). Они описывают создание более сложных объектов, либо упрощают работу с другими объектами системы.

`Adapter` - на основании некоторого класса создаем необходимый клиенту интерфейс;
`Facade` - описываем унифицированный интерфейс для облегчения работы с набором подсистем;
`Composite` - работаем с базовыми и составными объектами единым образом;
`Decorator` - динамически добавляем новую функциональность некоторому объекту, сохраняя его интерфейс;
`Proxy` - создаем объект, который перехватывает вызовы к другому объекту;
`Bridge` - разделяем абстракцию от интерфейса, позволяя им меняться независимо;
`Flyweight` - эффективно работаем с огромным количеством схожих объектов.

##Поведенческие паттерны проектирования

Наконец, третья группа - поведенческие шаблоны (behavioral). Они определяют эффективные способы взаимодействия различных объектов в системе.

`Strategy` - описываем набор взаимозаменяемых алгоритмов с единым интерфейсом;
`Iterator` - обеспечиваем доступ к коллекциям объектов без раскрытия внутреннего устройства этих коллекций;
`Observer` - создаем объект для отслеживания изменений в подсистеме и нотификации других подсистем;
`Memento` - сохраняем внутреннее состояние объекта для последующего использования без нарушения инкапсуляции;
`Command` - описываем объект, представляющий собой некоторое действие, которое можно выполнить в необходимый момент;
`Interpreter` - определяем способ вычисления выражений некоторого языка;
`Mediator` - создаем объект, которые регулирует взаимодействие между набором подсистем;
`State` - позволяем объекту менять свое поведение при изменении его внутреннего состояния;
`Template method` - описываем алгоритм, возлагая реализацию некоторых частей алгоритма на подклассы;
`Visitor` - отделяем алгоритм от структуры, с которыми алгоритм работает;
`Chain of responsibility` - пропускаем некоторый запрос через набор обработчиков событий, до тех пор пока запрос не будет обработан.